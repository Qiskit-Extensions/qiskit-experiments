# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""
Curve data classes.
"""

import dataclasses
import inspect
from typing import Any, Dict, Callable, Union, List, Tuple, Optional, Iterable

import numpy as np
import uncertainties
from qiskit_experiments.exceptions import AnalysisError


@dataclasses.dataclass(frozen=True)
class SeriesDef:
    """Description of curve."""

    # Arbitrary callback to define the fit function. First argument should be x.
    fit_func: Callable

    # Keyword dictionary to define the series with circuit metadata
    filter_kwargs: Dict[str, Any] = dataclasses.field(default_factory=dict)

    # Name of this series. This name will appear in the figure and raw x-y value report.
    name: str = "Series-0"

    # Color of this line.
    plot_color: str = "black"

    # Symbol to represent data points of this line.
    plot_symbol: str = "o"

    # Latex description of this fit model
    model_description: Optional[str] = None

    # Index of canvas if the result figure is multi-panel
    canvas: Optional[int] = None

    # Automatically extracted signature of the fit function
    signature: List[str] = dataclasses.field(init=False)

    # Name of group. Curves in the same group are simultaneously fit.
    group: Optional[str] = "default"

    def __post_init__(self):
        """Implicitly parse fit function signature for fit function."""
        # The first argument is x, which is not a fit parameter
        sig = list(inspect.signature(self.fit_func).parameters.keys())[1:]
        # Note that this dataclass is frozen
        object.__setattr__(self, "signature", sig)


class CompositeFitFunction:
    """Function-like object that is generated by a curve analysis subclass.

    This is function-like object that implements a fit model as a ``__call__`` magic method,
    thus it behaves as if a python function that the SciPy curve_fit solver accepts.
    Note that the fit function there only accepts variadic arguments.

    This class ties together the fit function and associated parameter names to
    perform correct parameter mapping among multiple objective functions with different signature,
    in which some parameters may be excluded from the fitting when they are fixed.
    """

    def __init__(
        self,
        group: str,
        fit_functions: [List[Callable]],
        signatures: List[List[str]],
        fixed_parameters: Optional[List[str]] = None,
        **metadata,
    ):
        """Create new composite function.

        Args:
            group: A name of the fit group that this function belongs to.
            fit_functions: List of callable that defines fit function of a single series.
            signatures: List of parameter names of a single series.
            fixed_parameters: List of parameter names that are fixed in the fit.
            **metadata: Arbitrary dictionary with information of this fit function.

        Raises:
            AnalysisError: When ``fit_functions`` and ``signatures`` don't match.
        """
        if len(fit_functions) != len(signatures):
            raise AnalysisError("Different numbers of fit_functions and signatures are given.")

        if fixed_parameters is None:
            fixed_parameters = tuple()

        self._group = group
        self._fit_functions = fit_functions
        self._signatures = signatures
        self._metadata = metadata or dict()

        # Parameters that can be overridden
        self._fixed_params = {p: None for p in fixed_parameters}
        self._data_index = None

        fit_args = []
        # Logic is not efficient but should keep order of parameters for backward compatibility
        for signature in signatures:
            for param in signature:
                if param not in fit_args and param not in fixed_parameters:
                    fit_args.append(param)

        self._full_params = fit_args

    def __call__(self, x: np.ndarray, *params) -> np.ndarray:
        """Called by the scipy fit function.

        Args:
            x: Composite X values array.
            *params: Variadic argument of fitting parameters.

        Returns:
            Computed Y values array.
        """
        kwparams = dict(zip(self._full_params, params))
        kwparams.update(self._fixed_params)

        y = np.zeros(x.size)
        for i, (func, sig) in enumerate(zip(self._fit_functions, self._signatures)):
            if self._data_index is not None:
                inds = self._data_index == i
            else:
                # Use all data if data index is not set
                inds = np.full(x.size, True, dtype=bool)

            y[inds] = func(x[inds], **{p: kwparams[p] for p in sig})

        return y

    def bind_parameters(self, **kwparams):
        """Set fixed parameters."""
        bind_dict = {k: kwparams[k] for k in self._fixed_params.keys() if k in kwparams}
        self._fixed_params.update(bind_dict)

    @property
    def data_index(self) -> np.ndarray:
        """Return current data index mapping."""
        return self._data_index

    @data_index.setter
    def data_index(self, new_indices: np.ndarray):
        """Set data index mapping for current fit data."""
        self._data_index = new_indices

    @property
    def signature(self) -> List[str]:
        """Return signature of the composite fit function."""
        return self._full_params

    @property
    def metadata(self) -> Dict[str, Any]:
        """Return metadata of this fit function."""
        return self._metadata

    @property
    def group(self) -> str:
        """Return a group that this function belongs to."""
        return self._group

    def copy(self):
        """Return copy of this function. Assigned parameters and indices are refleshed."""
        return CompositeFitFunction(
            group=self.group,
            fit_functions=self._fit_functions,
            signatures=self._signatures,
            fixed_parameters=list(self._fixed_params.keys()),
            **self.metadata.copy(),
        )

    def __repr__(self):
        sigrepr = ", ".join(self.signature)
        return f"{self.__class__.__name__}(x, {sigrepr}; group={self.group})"


@dataclasses.dataclass(frozen=True)
class CurveData:
    """Set of extracted experiment data."""

    # Name of this data set
    label: str

    # X data
    x: np.ndarray

    # Y data (measured data)
    y: np.ndarray

    # Error bar
    y_err: np.ndarray

    # Shots number
    shots: np.ndarray

    # Maping of data index to series index
    data_index: Union[np.ndarray, int]

    # Metadata associated with each data point. Generated from the circuit metadata.
    metadata: np.ndarray = None


@dataclasses.dataclass(frozen=True)
class FitData:
    """Set of data generated by the fit function."""

    # Order sensitive fit parameter values
    popt: List[uncertainties.UFloat]

    # Order sensitive parameter name list
    popt_keys: List[str]

    # Covariance matrix
    pcov: np.ndarray

    # Reduced Chi-squared value of fit curve
    reduced_chisq: float

    # Degree of freedom
    dof: int

    # X data range
    x_range: Tuple[float, float]

    # Y data range
    y_range: Tuple[float, float]

    # String representation of fit model
    fit_mdoel: str = "not defined"

    # String representation of the group that this fit belongs to.
    group: str = "default"

    def fitval(self, key: str) -> uncertainties.UFloat:
        """A helper method to get fit value object from parameter key name.

        Args:
            key: Name of parameters to extract.

        Returns:
            A UFloat object which functions as a standard Python float object
            but with automatic error propagation.

        Raises:
            ValueError: When specified parameter is not defined.
        """
        try:
            index = self.popt_keys.index(key)
            return self.popt[index]
        except ValueError as ex:
            raise ValueError(f"Parameter {key} is not defined.") from ex


@dataclasses.dataclass
class ParameterRepr:
    """Detailed description of fitting parameter."""

    # Fitter argument name
    name: str

    # Unicode representation
    repr: Optional[str] = None

    # Unit
    unit: Optional[str] = None


class OptionsDict(dict):
    """General extended dictionary for fit options.

    This dictionary provides several extra features.

    - A value setting method which validates the dict key and value.
    - Dictionary keys are limited to those specified in the constructor as ``parameters``.
    """

    def __init__(
        self,
        parameters: List[str],
        defaults: Optional[Union[Iterable[Any], Dict[str, Any]]] = None,
    ):
        """Create new dictionary.

        Args:
            parameters: List of parameter names used in the fit model.
            defaults: Default values.

        Raises:
            AnalysisError: When defaults is provided as array-like but the number of
                element doesn't match with the number of fit parameters.
        """
        if defaults is not None:
            if not isinstance(defaults, dict):
                if len(defaults) != len(parameters):
                    raise AnalysisError(
                        f"Default parameter {defaults} is provided with array-like "
                        "but the number of element doesn't match. "
                        f"This fit requires {len(parameters)} parameters."
                    )
                defaults = dict(zip(parameters, defaults))

            full_options = {p: self.format(defaults.get(p, None)) for p in parameters}
        else:
            full_options = {p: None for p in parameters}

        super().__init__(**full_options)

    def __setitem__(self, key, value):
        """Set value with validations.

        Raises:
            AnalysisError: When key is not previously defined.
        """
        if key not in self:
            raise AnalysisError(f"Parameter {key} is not defined in this fit model.")
        super().__setitem__(key, self.format(value))

    def __hash__(self):
        return hash(tuple(sorted(self.items())))

    def set_if_empty(self, **kwargs):
        """Set value to the dictionary if not assigned.

        Args:
              kwargs: Key and new value to assign.
        """
        for key, value in kwargs.items():
            if self.get(key) is None:
                self.__setitem__(key, value)

    @staticmethod
    def format(value: Any) -> Any:
        """Format dictionary value.

        Subcasses may override this method to provide their own validation.

        Args:
            value: New value to assign.

        Returns:
            Formatted value.
        """
        return value


class InitialGuesses(OptionsDict):
    """Dictionary providing a float validation for initial guesses."""

    @staticmethod
    def format(value: Any) -> Optional[float]:
        """Validate that value is float a float or None.

        Args:
            value: New value to assign.

        Returns:
            Formatted value.

        Raises:
            AnalysisError: When value is not a float or None.
        """
        if value is None:
            return None

        try:
            return float(value)
        except (TypeError, ValueError) as ex:
            raise AnalysisError(f"Input value {value} is not valid initial guess. ") from ex


class Boundaries(OptionsDict):
    """Dictionary providing a validation for boundaries."""

    @staticmethod
    def format(value: Any) -> Optional[Tuple[float, float]]:
        """Validate if value is a min-max value tuple.

        Args:
            value: New value to assign.

        Returns:
            Formatted value.

        Raises:
            AnalysisError: When value is invalid format.
        """
        if value is None:
            return None

        try:
            minv, maxv = value
            if minv >= maxv:
                raise AnalysisError(
                    f"The first value is greater than the second value {minv} >= {maxv}."
                )
            return float(minv), float(maxv)
        except (TypeError, ValueError) as ex:
            raise AnalysisError(f"Input boundary {value} is not a min-max value tuple.") from ex


# pylint: disable=invalid-name
class FitOptions:
    """Collection of fitting options.

    This class is initialized with a list of parameter names used in the fit model
    and corresponding default values provided by users.

    This class is hashable, and generates fitter keyword arguments.
    """

    def __init__(
        self,
        group: str,
        parameters: List[str],
        default_p0: Optional[Union[Iterable[float], Dict[str, float]]] = None,
        default_bounds: Optional[Union[Iterable[Tuple], Dict[str, Tuple]]] = None,
        **extra,
    ):
        self.group = group

        # These are private members so that user cannot directly override values
        # without implicitly implemented validation logic. No setter will be provided.
        self.__p0 = InitialGuesses(parameters, default_p0)
        self.__bounds = Boundaries(parameters, default_bounds)
        self.__extra = extra

    def __hash__(self):
        return hash((self.__p0, self.__bounds, tuple(sorted(self.__extra.items()))))

    def __eq__(self, other):
        if isinstance(other, FitOptions):
            checks = [
                self.__p0 == other.__p0,
                self.__bounds == other.__bounds,
                self.__extra == other.__extra,
            ]
            return all(checks)
        return False

    def add_extra_options(self, **kwargs):
        """Add more fitter options."""
        self.__extra.update(kwargs)

    def copy(self):
        """Create copy of this option."""
        return FitOptions(
            group=self.group,
            parameters=list(self.__p0.keys()),
            default_p0=dict(self.__p0),
            default_bounds=dict(self.__bounds),
            **self.__extra,
        )

    @property
    def p0(self) -> InitialGuesses:
        """Return initial guess dictionary."""
        return self.__p0

    @property
    def bounds(self) -> Boundaries:
        """Return bounds dictionary."""
        return self.__bounds

    @property
    def options(self):
        """Generate keyword arguments of the curve fitter."""
        bounds = {k: v if v is not None else (-np.inf, np.inf) for k, v in self.__bounds.items()}
        return {"p0": dict(self.__p0), "bounds": bounds, **self.__extra}
