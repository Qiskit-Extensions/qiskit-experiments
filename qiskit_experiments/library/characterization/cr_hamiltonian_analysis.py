# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Cross resonance Hamiltonian tomography experiment analysis."""

from collections import defaultdict
from typing import Any, Dict, List, Union

import numpy as np

import qiskit_experiments.curve_analysis as curve
import qiskit_experiments.data_processing as dp
from qiskit_experiments.database_service.device_component import Qubit
from qiskit_experiments.framework import AnalysisResultData, FitVal


class CrossResonanceHamiltonianAnalysis(curve.CurveAnalysis):
    r"""A class to analyze cross resonance Hamiltonian tomography experiment.

    # section: fit_model
        Following equations are used to approximate the dynamics of target qubit Bloch vector.

        .. math::

            F_{x, c}(t) &= \frac{1}{\Omega_c^2} \left(
                - p_{z, c} p_{x, c} + p_{z, c} p_{x, c} \cos(\Omega_c t) +
                \Omega_c p_{y, c} \sin(\Omega_c t) \right) + b \ ... \ (1), \\
            F_{y, c}(t) &= \frac{1}{\Omega_c^2} \left(
                p_{z, c} p_{y, c} - p_{z, c} p_{y, c} \cos(\Omega_c t) -
                \Omega_c p_{x, c} \sin(\Omega_c t) \right) + b \ ... \ (2), \\
            F_{z, c}(t) &= \frac{1}{\Omega_c^2} \left(
             p_{z, c}^2 + (p_{x, c}^2 + p_{y, c}^2) \cos(\Omega_c t) \right) + b \ ... \ (3),

        where :math:`\Omega_c = \sqrt{p_{x, c}^2+p_{y, c}^2+p_{z, c}^2}` and
        :math:`p_{x, c}, p_{y, c}, p_{z, c}, b` are the fit parameters.
        The subscript :math:`c` represents the state of control qubit :math:`c \in \{0, 1\}`.
        The fit functions :math:`F_{x, c}, F_{y, c}, F_{z, c}` approximate the Pauli expectation
        value of target qubit :math:`\langle \sigma_{x, c} (t) \rangle,
        \langle \sigma_{y, c} (t) \rangle, \langle \sigma_{z, c} (t) \rangle`, respectively.

        Based on the fit result, cross resonance Hamiltonian coefficients can be written as

        .. math::

            ZX &= \frac{p_{x, 0} - p_{x, 1}}{2} \\
            ZY &= \frac{p_{y, 0} - p_{y, 1}}{2} \\
            ZZ &= \frac{p_{z, 0} - p_{z, 1}}{2} \\
            IX &= \frac{p_{x, 0} + p_{x, 1}}{2} \\
            IY &= \frac{p_{y, 0} + p_{y, 1}}{2} \\
            IZ &= \frac{p_{z, 0} + p_{z, 1}}{2}

        In this analysis, initial guess is generated by the following equations.

        .. math::

            p_x &= \omega \cos(\theta) \cos(\phi) \\
            p_y &= \omega \cos(\theta) \sin(\phi) \\
            p_z &= \omega \sin(\theta)

        where $\omega$ is the mean oscillation frequency of eigenvalues,
        $\theta = \cos^{-1}\sqrt{\frac{\max F_z - \min F_z}{2}}$ and $\phi \in [-\pi, \pi]$.

    # section: fit_parameters

        defpar p_{x, 0}:
            desc: Fit parameter of oscillations when control qubit state is 0.
            init_guess: See fit model section.
            bounds: None

        defpar p_{y, 0}:
            desc: Fit parameter of oscillations when control qubit state is 0.
            init_guess: See fit model section.
            bounds: None

        defpar p_{z, 0}:
            desc: Fit parameter of oscillations when control qubit state is 0.
            init_guess: See fit model section.
            bounds: None

        defpar p_{x, 1}:
            desc: Fit parameter of oscillations when control qubit state is 1.
            init_guess: See fit model section.
            bounds: None

        defpar p_{y, 1}:
            desc: Fit parameter of oscillations when control qubit state is 1.
            init_guess: See fit model section.
            bounds: None

        defpar p_{z, 1}:
            desc: Fit parameter of oscillations when control qubit state is 1.
            init_guess: See fit model section.
            bounds: None

    """

    __series__ = [
        curve.SeriesDef(
            name="x|c=0",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_x(
                x, px=px0, py=py0, pz=pz0, baseline=b
            ),
            filter_kwargs={"control_state": 0, "meas_basis": "x"},
            plot_color="blue",
            plot_symbol="o",
            canvas=0,
        ),
        curve.SeriesDef(
            name="y|c=0",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_y(
                x, px=px0, py=py0, pz=pz0, baseline=b
            ),
            filter_kwargs={"control_state": 0, "meas_basis": "y"},
            plot_color="blue",
            plot_symbol="o",
            canvas=1,
        ),
        curve.SeriesDef(
            name="z|c=0",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_z(
                x, px=px0, py=py0, pz=pz0, baseline=b
            ),
            filter_kwargs={"control_state": 0, "meas_basis": "z"},
            plot_color="blue",
            plot_symbol="o",
            canvas=2,
        ),
        curve.SeriesDef(
            name="x|c=1",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_x(
                x, px=px1, py=py1, pz=pz1, baseline=b
            ),
            filter_kwargs={"control_state": 1, "meas_basis": "x"},
            plot_color="red",
            plot_symbol="^",
            canvas=0,
        ),
        curve.SeriesDef(
            name="y|c=1",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_y(
                x, px=px1, py=py1, pz=pz1, baseline=b
            ),
            filter_kwargs={"control_state": 1, "meas_basis": "y"},
            plot_color="red",
            plot_symbol="^",
            canvas=1,
        ),
        curve.SeriesDef(
            name="z|c=1",
            fit_func=lambda x, px0, px1, py0, py1, pz0, pz1, b: curve.fit_function.bloch_oscillation_z(
                x, px=px1, py=py1, pz=pz1, baseline=b
            ),
            filter_kwargs={"control_state": 1, "meas_basis": "z"},
            plot_color="red",
            plot_symbol="^",
            canvas=2,
        ),
    ]

    @classmethod
    def _default_options(cls):
        """Return the default analysis options."""
        default_options = super()._default_options()
        default_options.data_processor = dp.DataProcessor(
            input_key="counts", data_actions=[dp.Probability("1"), dp.Eigenvalue()]
        )
        default_options.curve_plotter = "mpl_multiv_canvas"
        default_options.xlabel = "Net cross resonance duration"
        default_options.ylabel = "<X(t)>,<Y(t)>,<Z(t)>"
        default_options.xval_unit = "s"
        default_options.style = curve.visualization.PlotterStyle(
            figsize=(8, 10),
            legend_loc="lower right",
            fit_report_rpos=(0.28, -0.10),
        )
        default_options.ylim = (-1, 1)

        return default_options

    def _setup_fitting(self, **extra_options) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """Fitter options."""
        user_p0 = self._get_option("p0")
        user_bounds = self._get_option("bounds")

        bounds = {
            "px0": user_bounds["px0"] or (-np.inf, np.inf),
            "py0": user_bounds["py0"] or (-np.inf, np.inf),
            "pz0": user_bounds["pz0"] or (-np.inf, np.inf),
            "px1": user_bounds["px1"] or (-np.inf, np.inf),
            "py1": user_bounds["py1"] or (-np.inf, np.inf),
            "pz1": user_bounds["pz1"] or (-np.inf, np.inf),
            "b": user_bounds["b"] or (-1, 1),
        }

        guesses = defaultdict(list)

        for control in (0, 1):
            # start from Z oscillation
            x_data = self._data(series_name=f"x|c={control}")
            y_data = self._data(series_name=f"y|c={control}")
            z_data = self._data(series_name=f"z|c={control}")

            omega_xyz = []
            for data in (x_data, y_data, z_data):
                fft_freq = curve.guess.frequency(data.x, data.y)
                # oscillation amplitude might be almost zero, then exclude from average
                if fft_freq > 0:
                    omega_xyz.append(fft_freq)
            if omega_xyz:
                omega = 2 * np.pi * np.average(omega_xyz)
            else:
                omega = 0.0

            zmin, zmax = np.percentile(z_data.y, [10, 90])
            zrange = zmax - zmin
            if zrange > 2.0:
                theta = 0.0
            else:
                theta = np.arccos(np.sqrt(zrange / 2))

            # The FFT might be up to 1/2 bin off
            df = 1 / ((z_data.x[1] - z_data.x[0]) * len(z_data.x))
            for omega_shifted in [omega, omega - df / 2, omega + df / 2]:
                for phi in np.linspace(-np.pi, np.pi, 9):
                    px = omega_shifted * np.cos(theta) * np.cos(phi)
                    py = omega_shifted * np.cos(theta) * np.sin(phi)
                    pz = omega_shifted * np.sin(theta)
                    guesses[control].append(
                        {
                            f"px{control}": user_p0[f"px{control}"] or px,
                            f"py{control}": user_p0[f"py{control}"] or py,
                            f"pz{control}": user_p0[f"pz{control}"] or pz,
                        }
                    )

        fit_options = []
        for p0s, p1s in zip(guesses[0], guesses[1]):
            fit_option = {
                "p0": {**p0s, **p1s, "b": user_p0["b"] or 1e-9},
                "bounds": bounds,
            }
            fit_option.update(extra_options)
            fit_options.append(fit_option)

        return fit_options

    def _evaluate_quality(self, fit_data: curve.FitData) -> Union[str, None]:
        """Algorithmic criteria for whether the fit is good or bad.

        A good fit has:
            - All fit parameter uncertainties are smaller than fit values.
        """
        criteria = []
        for control in (0, 1):
            for axis in ("x", "y", "z"):
                fit_par = fit_data.fitval(f"p{axis}{control}")
                criteria.append(fit_par.value > fit_par.stderr)

        if all(criteria):
            return "good"

        return "bad"

    def _extra_database_entry(self, fit_data: curve.FitData) -> List[AnalysisResultData]:
        """Calculate Hamiltonian coefficients from fit values."""
        extra_entries = []

        for control in ("z", "i"):
            for target in ("x", "y", "z"):
                p0_val = fit_data.fitval(f"p{target}0")
                p1_val = fit_data.fitval(f"p{target}1")

                if control == "z":
                    coef_val = 0.5 * (p0_val.value - p1_val.value) / (2 * np.pi)
                else:
                    coef_val = 0.5 * (p0_val.value + p1_val.value) / (2 * np.pi)

                coef_err = 0.5 * np.sqrt(p0_val.stderr ** 2 + p1_val.stderr ** 2) / (2 * np.pi)

                extra_entries.append(
                    AnalysisResultData(
                        name=f"omega_{control}{target}",
                        value=FitVal(value=coef_val, stderr=coef_err, unit="Hz"),
                        chisq=fit_data.reduced_chisq,
                        device_components=[Qubit(q) for q in self._physical_qubits],
                    )
                )

        return extra_entries
