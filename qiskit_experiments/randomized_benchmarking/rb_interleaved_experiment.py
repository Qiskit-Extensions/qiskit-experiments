# This code is part of Qiskit.
#
# (C) Copyright IBM 2019-2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
"""
Randomized benchmarking analysis classes
"""
# pylint: disable=no-name-in-module,import-error

from typing import List, Union, Optional, Dict
from numpy.random import RandomState
import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info.operators.symplectic.clifford import Clifford
from qiskit.quantum_info.operators.dihedral import CNOTDihedral
from qiskit.circuit import Instruction
from .base_rb_generator import RBGeneratorBase
from .base_rb_analysis import RBAnalysisBase, RBAnalysisResultBase
from .base_rb_experiment import RBExperimentBase
from .rb_experiment import RBAnalysis, CNOTDihedralRBAnalysis, RBAnalysisResult, CNOTDihedralRBResult
from ..experiment_data import ExperimentData


class InterleavedRBGenerator(RBGeneratorBase):
    """Generates circuits for interleaved RB
        In interleaved RB, we are given an additional element (which can be given as a
        quantum circuit, a gate or a group element), and for every RB circuit, another one
        is generated by interleaving the additional element between any two gates of the
        circuit.
        """
    def __init__(self,
                 interleaved_element:
                 Union[QuantumCircuit, Instruction,
                       Clifford, CNOTDihedral],
                 nseeds: int = 1,
                 qubits: List[int] = (0,),
                 lengths: List[int] = (1, 10, 20),
                 group_gates: Optional[str] = None,
                 rand_seed: Optional[Union[int, RandomState]] = None,
                 transform_interleaved_element: Optional[bool] = False
                 ):
        """Initialize the circuit generator for a standard randomized benchmarking experiment.
           Args:
               interleaved_element: the element to interleave, given either as a group element
               or as an instruction/circuit
               nseeds: number of different seeds (random circuits) to generate
               qubits: the qubits particiapting in the experiment
               lengths: for each seed, the lengths of the circuits used for that seed.
               group_gates: which group the circuits is based on
               rand_seed: optional random number seed
               transform_interleaved_element: when the interleaved element is gate or circuit, it
               can be kept as it is (`False`) or transofrmed to the group element and then
               transformed to the canonical circuit representation of that element (`True`)
        """
        super().__init__(nseeds,
                         qubits,
                         lengths,
                         group_gates,
                         rand_seed,
                         name="interleaved randomized benchmarking")

        self._transform_interleaved_element = transform_interleaved_element
        self.set_interleaved_element(interleaved_element)
        self.generate_circuits()

    def set_interleaved_element(self, interleaved_element: Union[QuantumCircuit,
                                                                 Instruction,
                                                                 Clifford,
                                                                 CNOTDihedral]):
        """Transform the interleaved element to a pair of circuit representation (circuit)
        and group representation (group element)
        Args:
            interleaved_element: the element to transform
        Raises:
            ValueError: If the interleaved element cannot be converted to a group element
        """
        group_gates_type = self._rb_group.group_gates_type()
        interleaved_group_element = interleaved_element
        if isinstance(interleaved_element, (QuantumCircuit, Instruction)):
            interleaved_group_element = self._rb_group.group_class()(interleaved_element)
        if (not isinstance(interleaved_group_element, Clifford) and
                group_gates_type == 0) and not (isinstance(interleaved_group_element, CNOTDihedral)
                                                and group_gates_type == 1):
            raise ValueError("Invalid interleaved element type.")

        if not isinstance(interleaved_group_element, Clifford) \
                and not isinstance(interleaved_group_element, CNOTDihedral):
            raise ValueError("Invalid interleaved element type. "
                             "interleaved_elem should be a list of QuantumCircuit,"
                             "or a list of Clifford / CNOTDihedral objects")
        if self._transform_interleaved_element:
            interleaved_circuit_element = self._rb_group.to_circuit(interleaved_group_element)
        else:
            if isinstance(interleaved_element, Instruction):
                c = QuantumCircuit(interleaved_element.num_qubits)
                c.append(interleaved_element, range(interleaved_element.num_qubits))
                interleaved_circuit_element = c
            else:
                interleaved_circuit_element = interleaved_element

        self._interleaved_element = {'group_element': interleaved_group_element,
                                     'circuit_element': interleaved_circuit_element
                                     }

    def generate_circuits_for_seed(self) -> List[Dict]:
        """Generates the standard RB circuits for a single seed
            Returns:
                The list of {'circuit': c, 'metadata': m} pairs
            Additional information:
                For interleaved RB, for every standard RB circuit, add an interleaved copy
                of that circuit to the circuit list as well, with corresponding meta
        """
        element_list = self.generate_random_element_list(self._lengths[-1])
        element_lists = self.split_element_list(element_list, self._lengths)
        circuits = self.generate_circuits_from_elements(element_lists)
        self.add_extra_meta(circuits, {
            'experiment_type': InterleavedRBExperiment.__name__,
            'circuit_type': 'standard'
        })

        element_list = self.interleave(element_list)
        element_lists = self.split_element_list(element_list, [2*x for x in self._lengths])
        interleaved_circuits = self.generate_circuits_from_elements(element_lists)
        self.add_extra_meta(interleaved_circuits, {
            'experiment_type': InterleavedRBExperiment.__name__,
            'circuit_type': 'interleaved'
        })
        return circuits + interleaved_circuits

    def interleave(self, element_list: List) -> List:
        """Interleaving the interleaved element inside the element list
        Args:
            element_list: The list of elements we add the interleaved element to
        Returns:
            The new list with the element interleaved
            """
        new_element_list = []
        for element in element_list:
            new_element_list.append(element)
            new_element_list.append(self._interleaved_element)
        return new_element_list

    def circuit_type_string(self, meta: Dict[str, any]) -> str:
        """Adds the "interleaved" label to the circuit type for the interleaved circuits
            Args:
                meta: The metadata of the circuit
            Returns:
                The type string for the circuit
        """
        if meta['circuit_type'] == 'interleaved':
            return "interleaved"
        return None

class InterleavedRBResult(RBAnalysisResultBase):
    """Class for interleaved randomized benchmarking analysis results"""
    def __init__(self, results):
        (std_fit_result, int_fit_result, interleaved_result) = results
        self._std_fit_result = RBAnalysisResult(std_fit_result)
        self._int_fit_result = RBAnalysisResult(int_fit_result)
        super().__init__(interleaved_result)

    def num_qubits(self) -> int:
        """Returns the number of qubits used in the RB experiment"""
        return self._std_fit_result.num_qubits()

    def plot_all_data_series(self, ax):
        """Plots the standard and interleaved data series"""
        self._std_fit_result.plot_data_series(ax, color='blue', label='Standard RB')
        self._int_fit_result.plot_data_series(ax, color='red', label='Interleaved RB')
        ax.legend(loc='lower left')

    def plot_label(self):
        """Plots interleaved fit results"""
        return "alpha: %.3f(%.1e) alpha_c: %.3e(%.1e) \n \
                            EPC_est: %.3e(%.1e)" % (self['alpha'],
                                                    self['alpha_err'],
                                                    self['alpha_c'],
                                                    self['alpha_c_err'],
                                                    self['epc_est'],
                                                    self['epc_est_err'])

class InterleavedCNOTDihedralRBResult(RBAnalysisResultBase):
    """Class for interleaved cnot-dihedral RB analysis results"""
    def __init__(self, results):
        (cnot_std_fit_result, cnot_int_fit_result, interleaved_result) = results
        self._cnot_std_fit_result = CNOTDihedralRBResult(cnot_std_fit_result)
        self._cnot_int_fit_result = CNOTDihedralRBResult(cnot_int_fit_result)
        super().__init__(interleaved_result)

    def num_qubits(self) -> int:
        """Returns the number of qubits used in the RB experiment"""
        return self._cnot_std_fit_result.num_qubits()

    def plot_all_data_series(self, ax):
        """Plots the Z and X basis data series for both standard and interleaved"""
        std_fit = self._cnot_std_fit_result
        int_fit = self._cnot_int_fit_result

        std_fit._z_fit_result.plot_data_series(ax, color='cyan', label='Standard RB in |0...0>')
        int_fit._z_fit_result.plot_data_series(ax, color='blue', label='Interleaved RB in |0...0>')
        std_fit._x_fit_result.plot_data_series(ax, color='yellow', label='Standard RB in |+...+>')
        int_fit._x_fit_result.plot_data_series(ax, color='red', label='Interleaved RB in |+...+>')
        ax.legend(loc='lower left')

    def plot_label(self):
        """Plots interleaved cnot-dihedral fit results"""
        return "alpha: %.3f(%.1e) alpha_c: %.3e(%.1e) \n \
                                    EPC_est: %.3e(%.1e)" % (self['alpha'],
                                                            self['alpha_err'],
                                                            self['alpha_c'],
                                                            self['alpha_c_err'],
                                                            self['epc_est'],
                                                            self['epc_est_err'])

class InterleavedRBAnalysis(RBAnalysisBase):
    """Analysis class for interleaved RB experiments"""
    __analysis_result_class__ = InterleavedRBResult

    def split_experiment_data(self, experiment_data):
        std_data = ExperimentData(experiment_data.experiment())
        int_data = ExperimentData(experiment_data.experiment())
        for d in experiment_data.data:
            if d['metadata']['circuit_type'] == 'standard':
                std_data.data.append(d)
            if d['metadata']['circuit_type'] == 'interleaved':
                int_data.data.append(d)
        return (std_data, int_data)

    @classmethod
    def set_result_class(cls, group_type):
        if group_type == 'clifford':
            cls.__analysis_result_class__ = InterleavedRBResult
        if group_type == 'cnot_dihedral':
            cls.__analysis_result_class__ = InterleavedCNOTDihedralRBResult

    def fit(self, experiment_data) -> RBAnalysisResultBase:
        """Computes the interleaved fit from the results of the two input fits
            Args:
                std_fit_results: The results for the standard RB fit
                int_fit_results: The results for the interleaved RB fit
            Returns:
                The interleaved result (which contains the input results)
        """

        num_qubits, lengths, group_type = self.get_experiment_params(experiment_data)
        self.set_result_class(group_type)
        (std_data, int_data) = self.split_experiment_data(experiment_data)
        if group_type == 'clifford':
            std_fit_results = RBAnalysis().fit(std_data)
            int_fit_results = RBAnalysis().fit(int_data)
            std_fit_data = std_fit_results
            int_fit_data = int_fit_results
        if group_type == 'cnot_dihedral':
            std_fit_results = CNOTDihedralRBAnalysis().fit(std_data)
            int_fit_results = CNOTDihedralRBAnalysis().fit(int_data)
            std_fit_data = std_fit_results[2]
            int_fit_data = int_fit_results[2]

        # calculate nrb=d=2^n:
        nrb = 2 ** num_qubits

        # Calculate alpha (=p) and alpha_c (=p_c):
        alpha = std_fit_data['alpha']
        alpha_c = int_fit_data['alpha']
        # Calculate their errors:
        alpha_err = std_fit_data['alpha_err']
        alpha_c_err = int_fit_data['alpha_err']

        # Calculate epc_est (=r_c^est) - Eq. (4):
        epc_est = (nrb - 1) * (1 - alpha_c / alpha) / nrb

        # Calculate the systematic error bounds - Eq. (5):
        systematic_err_1 = (nrb - 1) * (abs(alpha - alpha_c / alpha)
                                        + (1 - alpha)) / nrb
        systematic_err_2 = 2 * (nrb * nrb - 1) * (1 - alpha) / \
            (alpha * nrb * nrb) + 4 * (np.sqrt(1 - alpha)) * \
            (np.sqrt(nrb * nrb - 1)) / alpha
        systematic_err = min(systematic_err_1, systematic_err_2)
        systematic_err_l = epc_est - systematic_err
        systematic_err_r = epc_est + systematic_err

        # Calculate epc_est_error
        alpha_err_sq = (alpha_err / alpha) * (alpha_err / alpha)
        alpha_c_err_sq = (alpha_c_err / alpha_c) * (alpha_c_err / alpha_c)
        epc_est_err = ((nrb - 1) / nrb) * (alpha_c / alpha) \
            * (np.sqrt(alpha_err_sq + alpha_c_err_sq))

        interleaved_result = {'alpha': alpha,
                              'alpha_err': alpha_err,
                              'alpha_c': alpha_c,
                              'alpha_c_err': alpha_c_err,
                              'epc_est': epc_est,
                              'epc_est_err': epc_est_err,
                              'systematic_err':
                                  systematic_err,
                              'systematic_err_L':
                                  systematic_err_l,
                              'systematic_err_R':
                                  systematic_err_r,
                              'lengths': lengths,
                              'num_qubits': num_qubits,
                              'group_type': group_type}
        return (std_fit_results, int_fit_results, interleaved_result)

class InterleavedRBExperiment(RBExperimentBase):
    """Experiment class for interleaved RB experiment"""
    def __init__(self,
                 interleaved_element:
                 Union[QuantumCircuit, Instruction, Clifford, CNOTDihedral],
                 nseeds: int = 1,
                 qubits: List[int] = (0,),
                 lengths: List[int] = (1, 10, 20),
                 group_gates: Optional[str] = None,
                 rand_seed: Optional[Union[int, RandomState]] = None,
                 transform_interleaved_element: Optional[bool] = False
                 ):
        """Initialize the interleaved RB experiment
           Args:
               interleaved_element: the element to interleave, given either as a group element
               or as an instruction/circuit
               nseeds: number of different seeds (random circuits) to generate
               qubits: the qubits particiapting in the experiment
               lengths: for each seed, the lengths of the circuits used for that seed.
               group_gates: which group the circuits is based on
               rand_seed: optional random number seed
               transform_interleaved_element: when the interleaved element is gate or circuit, it
               can be kept as it is (`False`) or transofrmed to the group element and then
               transformed to the canonical circuit representation of that element (`True`)
        """
        generator = InterleavedRBGenerator(interleaved_element, nseeds, qubits, lengths,
                                           group_gates, rand_seed, transform_interleaved_element)

        self.__analysis_class__ = InterleavedRBAnalysis
        super().__init__(generator=generator)