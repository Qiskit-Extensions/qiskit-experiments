# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Cross resonance Hamiltonian tomography experiment analysis."""

from typing import List, Union

import lmfit
import numpy as np

import qiskit_experiments.curve_analysis as curve

import qiskit_experiments.data_processing as dp
from qiskit_experiments.framework import AnalysisResultData


class CrossResonanceHamiltonianAnalysis(curve.MultiGroupCurveAnalysis):
    r"""A class to analyze cross resonance Hamiltonian tomography experiment.

    # section: fit_model
        The following equations are used to approximate the dynamics of
        the target qubit Bloch vector.

        .. math::

            \begin{align}
                F_x(t) &= \frac{1}{\Omega^2} \left(
                    - p_z p_x + p_z p_x \cos(\Omega t') +
                    \Omega p_y \sin(\Omega t') \right) + b \tag{1} \\
                F_y(t) &= \frac{1}{\Omega^2} \left(
                    p_z p_y - p_z p_y \cos(\Omega t') -
                    \Omega p_x \sin(\Omega t') \right) + b \tag{2} \\
                F_z(t) &= \frac{1}{\Omega^2} \left(
                    p_z^2 + (p_x^2 + p_y^2) \cos(\Omega t') \right) + b \tag{3}
            \end{align}

        where :math:`t' = t + t_{\rm offset}` with :math:`t` is pulse duration to scan
        and :math:`t_{\rm offset}` is an extra fit parameter that may represent the edge effect.
        The :math:`\Omega = \sqrt{p_x^2+p_y^2+p_z^2}`, and :math:`p_x, p_y, p_z, b` are fit parameters.
        The fit functions :math:`F_x, F_y, F_z` approximate the Pauli expectation
        values :math:`\langle \sigma_x (t) \rangle, \langle \sigma_y (t) \rangle,
        \langle \sigma_z (t) \rangle` of the target qubit, respectively.

        This fitting is performed for two experiment results for different control qubit state
        in :\math:`c \in [|0\rangle, |1\rangle]`.
        Based on the fit result, cross resonance Hamiltonian coefficients can be written as

        .. math::

            ZX &= \frac{p_{x, |0\rangle} - p_{x, |1\rangle}}{2} \\
            ZY &= \frac{p_{y, |0\rangle} - p_{y, |1\rangle}}{2} \\
            ZZ &= \frac{p_{z, |0\rangle} - p_{z, |1\rangle}}{2} \\
            IX &= \frac{p_{x, |0\rangle} + p_{x, |1\rangle}}{2} \\
            IY &= \frac{p_{y, |0\rangle} + p_{y, |1\rangle}}{2} \\
            IZ &= \frac{p_{z, |0\rangle} + p_{z, |1\rangle}}{2}

        In this analysis, the initial guess is generated by the following equations.

        .. math::

            p_x &= \omega \cos(\theta) \cos(\phi) \\
            p_y &= \omega \cos(\theta) \sin(\phi) \\
            p_z &= \omega \sin(\theta)

        where :math:`\omega` is the mean oscillation frequency of eigenvalues,
        :math:`\theta = \cos^{-1}\sqrt{\frac{\max F_z - \min F_z}{2}}`
        and :math:`\phi \in [-\pi, \pi]`.

    # section: fit_parameters

        defpar t_{\rm off}:
            desc: Offset to the pulse duration. For example, if pulse envelope is
                a flat-topped Gaussian, two Gaussian edges may become an offset duration.
            init_guess: Computed as :math:`N \sqrt{2 \pi} \sigma` where the :math:`N` is number of
                pulses and :math:`\sigma` is Gaussian sigma of rising and falling edges.
                Note that this implicitly assumes the :py:class:`~qiskit.pulse.library\
                .parametric_pulses.GaussianSquare` pulse envelope.
            bounds: [0, None]

        defpar p_x:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_y:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_z:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar b:
            desc: Vertical offset of oscillations. This may indicate the state preparation and
                measurement error.
            init_guess: 0
            bounds: None

    # section: see_also
        qiskit_experiments.library.characterization.cr_hamiltonian.CrossResonanceHamiltonian

    """

    def __init__(self):

        eqr_temps = {
            "x": "(-pz * px + pz * px * cos(W * X) + W * py * sin(W * X)) / W**2 + b",
            "y": "(pz * py - pz * py * cos(W * X) - W * px * sin(W * X)) / W**2 + b",
            "z": "(pz**2 + (px**2 + py**2) * cos(W * X)) / W**2 + b",
        }

        models = []
        for axis, temp_eq in eqr_temps.items():
            eq = temp_eq
            eq = eq.replace("W", "sqrt(px**2 + py**2 + pz**2)")
            eq = eq.replace("X", "(x + t_off)")
            models.append(
                lmfit.models.ExpressionModel(
                    expr=eq,
                    name=f"{axis}",
                    data_sort_key={"meas_basis": axis},
                )
            )

        super().__init__(
            groups=["ctrl0", "ctrl1"],
            group_data_sort_key=[{"control_state": 0}, {"control_state": 1}],
            models=models,
        )

    @classmethod
    def _default_options(cls):
        """Return the default analysis options."""
        default_options = super()._default_options()
        default_options.curve_drawer.set_options(
            subplots=(3, 1),
            xlabel="Flat top width",
            ylabel=[
                r"$\langle$X(t)$\rangle$",
                r"$\langle$Y(t)$\rangle$",
                r"$\langle$Z(t)$\rangle$",
            ],
            xval_unit="s",
            figsize=(8, 10),
            legend_loc="lower right",
            fit_report_rpos=(0.28, -0.10),
            ylim=(-1, 1),
            plot_options={
                "x_ctrl0": {"color": "blue", "symbol": "o", "canvas": 0},
                "y_ctrl0": {"color": "blue", "symbol": "o", "canvas": 1},
                "z_ctrl0": {"color": "blue", "symbol": "o", "canvas": 2},
                "x_ctrl1": {"color": "red", "symbol": "^", "canvas": 0},
                "y_ctrl1": {"color": "red", "symbol": "^", "canvas": 1},
                "z_ctrl1": {"color": "red", "symbol": "^", "canvas": 2},
            },
        )
        default_options.data_processor = dp.DataProcessor(
            input_key="counts",
            data_actions=[dp.Probability("1"), dp.BasisExpectationValue()],
        )

        return default_options

    def _generate_fit_guesses(
        self,
        user_opt: curve.FitOptions,
        curve_data: curve.CurveData,
    ) -> Union[curve.FitOptions, List[curve.FitOptions]]:
        """Create algorithmic guess with analysis options and curve data.

        Args:
            user_opt: Fit options filled with user provided guess and bounds.
            curve_data: Formatted data collection to fit.

        Returns:
            List of fit options that are passed to the fitter function.
        """
        fit_options = []

        user_opt.bounds.set_if_empty(t_off=(0, np.inf), b=(-1, 1))
        user_opt.p0.set_if_empty(b=1e-9)

        x_data = curve_data.get_subset_of("x")
        y_data = curve_data.get_subset_of("y")
        z_data = curve_data.get_subset_of("z")

        omega_xyz = []
        for data in (x_data, y_data, z_data):
            ymin, ymax = np.percentile(data.y, [10, 90])
            if ymax - ymin < 0.2:
                # oscillation amplitude might be almost zero,
                # then exclude from average because of lower SNR
                continue
            fft_freq = curve.guess.frequency(data.x, data.y)
            omega_xyz.append(fft_freq)
        if omega_xyz:
            omega = 2 * np.pi * np.average(omega_xyz)
        else:
            omega = 1e-3

        zmin, zmax = np.percentile(z_data.y, [10, 90])
        theta = np.arccos(np.sqrt((zmax - zmin) / 2))

        # The FFT might be up to 1/2 bin off
        df = 2 * np.pi / ((z_data.x[1] - z_data.x[0]) * len(z_data.x))
        for omega_shifted in [omega, omega - df / 2, omega + df / 2]:
            for phi in np.linspace(-np.pi, np.pi, 5):
                new_opt = user_opt.copy()
                new_opt.p0.set_if_empty(
                    px=omega_shifted * np.cos(theta) * np.cos(phi),
                    py=omega_shifted * np.cos(theta) * np.sin(phi),
                    pz=omega_shifted * np.sin(theta),
                )
                fit_options.append(new_opt)
        if omega < df:
            # empirical guess for low frequency case
            new_opt = user_opt.copy()
            new_opt.p0.set_if_empty(px=omega, py=omega, pz=0)
            fit_options.append(new_opt)

        return fit_options

    def _create_composite_analysis_results(
        self,
        fit_dataset: List[curve.CurveFitResult],
        quality: str,
        **metadata,
    ) -> List[AnalysisResultData]:
        outcomes = []

        for control in ("z", "i"):
            for target in ("x", "y", "z"):
                p0_val = fit_dataset[0].ufloat_params[f"p{target}"]
                p1_val = fit_dataset[1].ufloat_params[f"p{target}"]

                if control == "z":
                    coef_val = 0.5 * (p0_val - p1_val) / (2 * np.pi)
                else:
                    coef_val = 0.5 * (p0_val + p1_val) / (2 * np.pi)

                outcomes.append(
                    AnalysisResultData(
                        name=f"omega_{control}{target}",
                        value=coef_val,
                        quality=quality,
                        extra={
                            "unit": "Hz",
                            **metadata,
                        },
                    )
                )

        return outcomes
